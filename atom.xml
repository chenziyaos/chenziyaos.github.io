<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>非衣</title>
  <subtitle>心静如水</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://iceziyao.github.io/"/>
  <updated>2016-07-09T21:00:02.325Z</updated>
  <id>https://iceziyao.github.io/</id>
  
  <author>
    <name>陈子瑶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python的内存管理机制</title>
    <link href="https://iceziyao.github.io/2016/05/21/python01/"/>
    <id>https://iceziyao.github.io/2016/05/21/python01/</id>
    <published>2016-05-20T16:00:00.000Z</published>
    <updated>2016-07-09T21:00:02.325Z</updated>
    
    <content type="html">&lt;h2 id=&quot;python的内存管理分为三个方面：&quot;&gt;&lt;a href=&quot;#python的内存管理分为三个方面：&quot; class=&quot;headerlink&quot; title=&quot;python的内存管理分为三个方面：&quot;&gt;&lt;/a&gt;python的内存管理分为三个方面：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;em&gt;引用计数&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;垃圾回收&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;内存池机制&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;浅析引用计数&lt;br&gt;python内部使用引用计数，来保持追踪内存中的对象，Python内部记录了对象有多少个引用，即引用计数，当对象被创建时就创建了一个引用计数，当对象不再需要时，这个对象的引用计数为0时，它被垃圾回收。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;引用计数增加的情况：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.对象被创建：x=4&lt;br&gt;2.另外的别人被创建：y=x&lt;br&gt;3.被作为参数传递给函数：foo(x)&lt;br&gt;4.作为容器对象的一个元素：a=[1,x,’33’]  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;引用计数减少情况  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.一个本地引用离开了它的作用域。比如上面的foo(x)函数结束时，x指向的对象引用减1。&lt;br&gt;2.对象的别名被显式的销毁：del x ；或者del y&lt;br&gt;3.对象的一个别名被赋值给其他对象：x=789&lt;br&gt;4.对象从一个窗口对象中移除：myList.remove(x)&lt;br&gt;5.窗口对象本身被销毁：del myList，或者窗口对象本身离开了作用域。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如何获取一个变量的引用计数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&gt;&gt; import sys
&gt;&gt; x = 1
&gt;&gt; sys.getrefcount(x)
599
&gt;&gt; y = x
&gt;&gt; sys.getrefcount(x)
600
&gt;&gt; del y
&gt;&gt; sys.getrefcount(x)
599
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;垃圾回收&lt;br&gt;python的垃圾回收机制以引用计数为主，标记-清除和分代收集为辅。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2.1 引用计数  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;优点：“实时性”，任何内存，一旦没有指向它的引用，就会立即被回收。&lt;br&gt;缺点：&lt;br&gt;(1). 效率底下：引用计数机制带来的计数操作，与引用赋值成正比。频繁的技术操作，会给CPU带来大量消耗。&lt;br&gt;(2). 循环引用：也就是两个对象相互引用，这样的话，两个对象的引用计数永远不会为0，及它们永远不被清除。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.2 标记-清除&lt;br&gt;标记-清除是为了解决循环引用的问题。可以包含其他对象引用的容器对象（比如：list，set，dict，class，instance）都可能产生循环引用。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2.2.1 假设&lt;br&gt;如果两个对象的引用计数都为1的话，但仅仅存在它们之间的相互引用，那么，我们可以认为这两个对象的实际引用计数为0.如果我们将这个引用循环去掉，那么它们的实际引用计数才会显现。&lt;br&gt;案例：有循环引用的A,B两个对象，从A出发，因为它有一个对B的引用，则将B的引用计数减1；然后顺着引用达到B，因为B有一个对A的引用，同样将A的引用减1，这样，就完成了循环引用对象间环摘除。&lt;br&gt;问题：如果A,B间没有循环引用，但A引用了B，B没有以用A，贸然的将B计数引用减1，而A没有被回收，这将导致在未来的某个时刻出现一个对B的悬空引用，类似与C的空指针异常。这就要求我们必须在A没有被删除的情况下复原B的引用计数，那么维护引用计数的复杂度将成倍增加。&lt;br&gt;2.2.2 标记-清除的原理&lt;br&gt;原理：&lt;br&gt;我们并不改动真实的引用计数，而是将集合中对象的引用计数复制一份副本，改动该对象引用的副本。对于副本做任何的改动，都不会影响到对象生命走起的维护。&lt;br&gt;这个计数副本的唯一作用是寻找root object集合（该集合中的对象是不能被回收的）。当成功寻找到root object集合之后，首先将现在的内存链表一分为二，一条链表中维护root object集合，成为root链表，而另外一条链表中维护剩下的对象，成为unreachable链表。之所以要剖成两个链表，是基于这样的一种考虑：现在的unreachable可能存在被root链表中的对象，直接或间接引用的对象，这些对象是不能被回收的，一旦在标记的过程中，发现这样的对象，就将其从unreachable链表中移到root链表中；当完成标记后，unreachable链表中剩下的所有对象就是名副其实的垃圾对象了，接下来的垃圾回收只需限制在unreachable链表中即可。&lt;br&gt;效率分析：&lt;br&gt;从垃圾收集机制来看，这种垃圾收集机制所带来的额外操作实际上与系统中总的内存块的数量是相关的，当需要回收的内存块越多时，垃圾检测带来的额外操作就越多，而垃圾回收带来的额外操作就越少；反之，当需回收的内存块越少时，垃圾检测就将比垃圾回收带来更少的额外操作。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.3 分代回收  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2.3.1 理论：&lt;br&gt;无论使用何种语言开发，无论开发的是何种类型，何种规模的程序，都存在这样一点相同之处。即：一定比例的内存块的生存周期都比较短，通常是几百万条机器指令的时间，而剩下的内存块，起生存周期比较长，甚至会从程序开始一直持续到程序结束。&lt;br&gt;2.3.2 原理：&lt;br&gt;将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。也就是符合马太福音，存活久的让它继续存活下去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存池机制    &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3.1 内存分配层次：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Python的内存机制以金字塔层次：&lt;br&gt;　　   -1，-2层主要有操作系统进行操作，&lt;br&gt;　　第0层是C中的malloc，free等内存分配和释放函数进行操作；&lt;br&gt;　　第1层和第2层是内存池，有Python的接口函数PyMem_Malloc函数实现，当对象小于256K时有该层直接分配内存；&lt;br&gt;　　第3层是最上层，也就是我们对Python对象的直接操作；  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3.2 原因  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 C 中如果频繁的调用 malloc 与 free 时,是会产生性能问题的.再加上频繁的分配与释放小块的内存会产生内存碎片。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3.3 具现化  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;　　Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。&lt;br&gt;　　Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的 malloc。另外Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。&lt;br&gt;　　在Python中，许多时候申请的内存都是小块的内存，这些小块内存在申请后，很快又会被释放，由于这些内存的申请并不是为了创建对象，所以并没有对象一级的内存池机制。这就意味着Python在运行期间会大量地执行malloc和free的操作，频繁地在用户态和核心态之间进行切换，这将严重影响 Python的执行效率。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。这也就是之前提到的 Pymalloc机制。&lt;br&gt;　　Pymalloc 关于释放内存方面，当一个对象的 引用计数变为0时，python就会调用它的析构函数。在析构时，也采用了内存池机制，从内存池来的内存会被归还到内存池中，以避免频繁地释放动作。&lt;br&gt;　　Pymalloc分配一系列256KB的内存块，称之为arena。每个arena分割为4KB大小的内存池Pool，每个Pool再切分为固定大小的Block。在内存分配时，分配给进程的就是这些Blocks。&lt;br&gt;&lt;a href=&quot;http://nodefe.com/implement-of-pymalloc-from-source/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;需要了解Pymalloc的看这篇博文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;python的内存管理分为三个方面：&quot;&gt;&lt;a href=&quot;#python的内存管理分为三个方面：&quot; class=&quot;headerlink&quot; title=&quot;python的内存管理分为三个方面：&quot;&gt;&lt;/a&gt;python的内存管理分为三个方面：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://iceziyao.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Memcached简介</title>
    <link href="https://iceziyao.github.io/2016/01/01/Memcached/"/>
    <id>https://iceziyao.github.io/2016/01/01/Memcached/</id>
    <published>2016-01-01T13:49:33.000Z</published>
    <updated>2016-07-09T15:46:50.804Z</updated>
    
    <content type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Memcached是一款开源、高性能、分布式内存对象缓存系统，可应用各种需要缓存的场景，其主要目的是通过降低对Database的访问来加速web应用程序。它是一个基于内存的“键值对”存储，用于存储数据库调用、API调用或页面引用结果的直接数据，如字符串、对象等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;memcached是以LiveJournal旗下Danga Interactive 公司的Brad Fitzpatric 为首开发的一款软件。现在&lt;br&gt;已成为mixi、hatena、Facebook、Vox、LiveJournal等众多服务中提高Web应用扩展性的重要因素。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Memcached是一款开发工具，它既不是一个代码加速器，也不是数据库中间件。其设计哲学思想主要反映在如下方面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;简单key/value存储：服务器不关心数据本身的意义及结构，只要是可序列化数据即可。存储项由“键、过期时间、可选的标志及数据”四个部分组成；  &lt;/li&gt;
&lt;li&gt;功能的实现一半依赖于客户端，一半基于服务器端：客户负责发送存储项至服务器端、从服务端获取数据以及无法连接至服务器时采用相应的动作；服务端负责接收、存储数据，并负责数据项的超时过期；  &lt;/li&gt;
&lt;li&gt;各服务器间彼此无视：不在服务器间进行数据同步；  &lt;/li&gt;
&lt;li&gt;O(1)的执行效率  &lt;/li&gt;
&lt;li&gt;清理超期数据：默认情况下，Memcached是一个LRU缓存，同时，它按事先预订的时长清理超期数据；&lt;br&gt;但事实上，memcached不会删除任何已缓存数据，只是在其过期之后不再为客户所见；&lt;br&gt;而且，memcached也不会真正按期限清理缓存，而仅是当get命令到达时检查其时长；   &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Memcached提供了为数不多的几个命令来完成与服务器端的交互，这些命令基于memcached的协议实现。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;存储类命令：set, add, replace, append, prepend&lt;br&gt;获取数据类命令：get, delete, incr/decr&lt;br&gt;统计类命令：stats, stats items, stats slabs, stats sizes&lt;br&gt;清理命令： flush_all  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一、安装libevent&lt;br&gt;memcached依赖于libevent API，因此要事先安装之，项目主页：&lt;a href=&quot;http://libevent.org/，读者可自行选择需要的版本下载。本文采用的是目前最新版本的源码包libevent-2.0.16-stable.tar.gz。安装过程：&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://libevent.org/，读者可自行选择需要的版本下载。本文采用的是目前最新版本的源码包libevent-2.0.16-stable.tar.gz。安装过程：&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
# tar xf libevent-2.0.20-stable.tar.gz
# cd libevent-2.0.20
# ./configure --prefix=/usr/local/libevent
# make &amp;&amp; make install

# echo &quot;/usr/local/libevent/lib&quot; &gt; /etc/ld.so.conf.d/libevent.conf
# ldconfig
&lt;/code&gt;&lt;/pre&gt;
二、安装配置memcached

1. 安装memcached
&lt;pre&gt;&lt;code&gt;
# tar xf memcached-1.4.15.tar.gz
# cd memcached-1.4.15
# ./configure --prefix=/usr/local/memcached --with-libevent=/usr/local/libevent
# make &amp;&amp; make install
&lt;/code&gt;&lt;/pre&gt;
2. memcached SysV的startup脚本代码如下所示，将其建立为/etc/init.d/memcached文件：
&lt;pre&gt;&lt;code&gt;
#!/bin/bash
#
# Init file for memcached
#
# chkconfig: - 86 14
# description: Distributed memory caching daemon
#
# processname: memcached
# config: /etc/sysconfig/memcached
. /etc/rc.d/init.d/functions
## Default variables
PORT=&quot;11211&quot;
USER=&quot;nobody&quot;
MAXCONN=&quot;1024&quot;
CACHESIZE=&quot;64&quot;
OPTIONS=&quot;&quot;
RETVAL=0
prog=&quot;/usr/local/memcached/bin/memcached&quot;
desc=&quot;Distributed memory caching&quot;
lockfile=&quot;/var/lock/subsys/memcached&quot;
start() {
        echo -n $&quot;Starting $desc (memcached): &quot;
        daemon $prog -d -p $PORT -u $USER -c $MAXCONN -m $CACHESIZE -o &quot;$OPTIONS&quot;
        RETVAL=$?
        echo
        [ $RETVAL -eq 0 ] &amp;&amp; touch $lockfile
        return $RETVAL
}
stop() {
        echo -n $&quot;Shutting down $desc (memcached): &quot;
        killproc $prog
        RETVAL=$?
        echo
        [ $RETVAL -eq 0 ] &amp;&amp; rm -f $lockfile
        return $RETVAL
}
restart() {
        stop
        start
}
reload() {
        echo -n $&quot;Reloading $desc ($prog): &quot;
        killproc $prog -HUP
        RETVAL=$?
        echo
        return $RETVAL
}
case &quot;$1&quot; in
  start)
        start
        ;;
  stop)
        stop
        ;;
  restart)
        restart
        ;;
  condrestart)
        [ -e $lockfile ] &amp;&amp; restart
        RETVAL=$?
        ;;       
  reload)
        reload
        ;;
  status)
        status $prog
        RETVAL=$?
        ;;
   \*)
        echo $&quot;Usage: $0 {start|stop|restart|condrestart|status}&quot;
        RETVAL=1
esac
exit $RETVAL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用如下命令配置memcached成为系统服务：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
# chmod +x /etc/init.d/memcached
# chkconfig --add memcached
# service memcached start
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;使用telnet命令测试memcached的使用&lt;br&gt;Memcached提供一组基本命令用于基于命令行调用其服务或查看服务器状态等。&lt;br&gt;&lt;code&gt;telnet 127.0.0.1 11211&lt;/code&gt;  &lt;blockquote&gt;
&lt;p&gt;add命令：&lt;br&gt;add keyname flag  timeout  datasize&lt;br&gt;如：&lt;br&gt;add mykey 0 10 12&lt;br&gt;Hello world!&lt;br&gt;get命令：&lt;br&gt;get keyname&lt;br&gt;如：get mykey&lt;br&gt;VALUE mykey 0 12&lt;br&gt;Hello world!&lt;br&gt;END  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;4.memcached的常用选项说明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
-l &lt;ip_addr&gt;：指定进程监听的地址；
-d: 以服务模式运行；
-u &lt;username&gt;：以指定的用户身份运行memcached进程；
-m &lt;num&gt;：用于缓存数据的最大内存空间，单位为MB，默认为64MB；
-c &lt;num&gt;：最大支持的并发连接数，默认为1024；
-p &lt;num&gt;: 指定监听的TCP端口，默认为11211；
-U &lt;num&gt;：指定监听的UDP端口，默认为11211，0表示关闭UDP端口；
-t &lt;threads&gt;：用于处理入站请求的最大线程数，仅在memcached编译时开启了支持线程才有效；
-f &lt;num&gt;：设定Slab Allocator定义预先分配内存空间大小固定的块时使用的增长因子；
-M：当内存空间不够使用时返回错误信息，而不是按LRU算法利用空间；
-n: 指定最小的slab chunk大小；单位是字节；
-S: 启用sasl进行用户认证；
&lt;/num&gt;&lt;/threads&gt;&lt;/num&gt;&lt;/num&gt;&lt;/num&gt;&lt;/num&gt;&lt;/username&gt;&lt;/ip_addr&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三、安装Memcache的PHP扩展&lt;/p&gt;
&lt;p&gt;①安装PHP的memcache扩展&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
# tar xf memcache-2.2.5.tgz
# cd memcache-2.2.5
/usr/local/php/bin/phpize
# ./configure --with-php-config=/usr/local/php/bin/php-config --enable-memcache
# make &amp;&amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述安装完后会有类似以下的提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Installing shared extensions:     /usr/local/php/lib/php/extensions/no-debug-non-zts-20090626/  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;②编辑/usr/local/php/lib/php.ini，在“动态模块”相关的位置添加如下一行来载入memcache扩展：&lt;br&gt;extension=/usr/local/php/lib/php/extensions/no-debug-non-zts-20090626/memcache.so&lt;br&gt;而后对memcached功能进行测试，在网站目录中建立测试页面test.php，添加如下内容：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;?php
$mem = new Memcache;
$mem-&gt;connect(&quot;127.0.0.1&quot;, 11211)  or die(&quot;Could not connect&quot;);
$version = $mem-&gt;getVersion();
echo &quot;Server&#39;s version: &quot;.$version.&quot;&lt;br&gt;\n&quot;;
$mem-&gt;set(&#39;testkey&#39;, &#39;Hello World&#39;, 0, 600) or die(&quot;Failed to save data at the memcached server&quot;);
echo &quot;Store data in the cache (data will expire in 600 seconds)&lt;br&gt;\n&quot;;
$get_result = $mem-&gt;get(&#39;testkey&#39;);
echo &quot;$get_result is from memcached server.&quot;;         
?&gt;
&lt;/code&gt;&lt;/pre&gt;  

&lt;p&gt;如果有输出”Hello World is from memcached”&lt;br&gt;等信息，则表明memcache已经能够正常工作&lt;/p&gt;
&lt;p&gt;四. 使用libmemcached的客户端工具:&lt;/p&gt;
&lt;p&gt;访问memcached的传统方法是使用基于perl语言开发的Cache::memcached模块，这个模块在大多数perl代码中都能良好的工作，但也有着众所周知的性能方面的问题。libMemcached则是基于C语言开发的开源的C/C++代码访问memcached的库文件，同时，它还提供了数个可以远程使用的memcached管理工具，如memcat, memping，memstat，memslap等。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编译安装libmemcached&lt;pre&gt;&lt;code&gt;
# tar xf libmemcached-1.0.2.tar.gz
# cd libmemcached-1.0.2
# ./configure
# make &amp;&amp; make install
# ldconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;客户端工具&lt;pre&gt;&lt;code&gt;
# memcat --servers=127.0.0.1:11211 mykey
# memping
# memslap
# memstat
&lt;/code&gt;&lt;/pre&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;五. Nginx整合memcached:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
server {
        listen       80;
        server_name  www.magedu.com;
        #charset koi8-r;
        #access_log  logs/host.access.log  main;
        location / {
                set $memcached_key $uri;
                memcached_pass     127.0.0.1:11211;
                default_type       text/html;
                error_page         404 @fallback;
        }
        location @fallback {
                proxy_pass http://172.16.0.1;
        }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;Memcached是一款开源、高性能、分布式内存对象缓存系统，可应用各种需要缓存的场景，其主要目的是通过降低对Database的访问来加速web应用程序。它是一个基于内存的“键值对”存储，用于存储数据库调用、API调用或页面引用结果的直接数据，如字符串、对
    
    </summary>
    
    
      <category term="缓存" scheme="https://iceziyao.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>nginx负载均衡</title>
    <link href="https://iceziyao.github.io/2015/12/23/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://iceziyao.github.io/2015/12/23/nginx负载均衡/</id>
    <published>2015-12-23T13:49:33.000Z</published>
    <updated>2016-07-09T15:47:21.221Z</updated>
    
    <content type="html">&lt;h3 id=&quot;安装nginx&quot;&gt;&lt;a href=&quot;#安装nginx&quot; class=&quot;headerlink&quot; title=&quot;安装nginx&quot;&gt;&lt;/a&gt;安装nginx&lt;/h3&gt;&lt;p&gt;请参考&lt;a href=&quot;http://www.yaolinux.cn/blog/lnmp%25E6%259E%25B6%25E6%259E%2584.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;lnmp架构&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;nginx 反向代理&lt;br&gt;nginx的负载均衡基于反向代理  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.1 正向代理  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 正向代理 是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.2反向代理&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;反向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;区别:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。&lt;br&gt;正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;upstream&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2.1 负载均衡算法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2.1.1 轮循&lt;br&gt;当weight不指定时，各服务器weight相同，&lt;br&gt;每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
upstream bakend {
server server1.example.com;
server server2.example.com;
}
&lt;/code&gt;&lt;/pre&gt;
2.1.2 weight    
指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。
如果后端服务器down掉，能自动剔除。
比如以下配置，则1.11服务器的访问量为1.10服务器的两倍。  
&lt;pre&gt;&lt;code&gt;
upstream bakend {
server server1.example.com weight=1;
server server2.example.com weight=2;
}
&lt;/code&gt;&lt;/pre&gt;
2.1.3 ip_hash        
每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session不能跨服务器的问题。  
&lt;pre&gt;&lt;code&gt;
upstream bakend {
ip_hash
server server1.example.com;
server server2.example.com;
}
&lt;/code&gt;&lt;/pre&gt;
2.1.4 fair  
按后端服务器的响应时间来分配请求，响应时间短的优先分配。  
&lt;pre&gt;&lt;code&gt;
upstream bakend {
server server1.example.com;
server server2.example.com;
fair;
}
&lt;/code&gt;&lt;/pre&gt;
2.1.5 url_hash  
按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存服务器时比较有效。
在upstream中加入hash语句，hash_method是使用的hash算法。  
&lt;pre&gt;&lt;code&gt;
upstream bakend {
server server1.example.com;
server server2.example.com;
hash $request_uri;
hash_method crc32;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;/blockquote&gt;
&lt;p&gt;2.2 参数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.down 表示单前的server暂时不参与负载&lt;br&gt;2.weight 默认为1.weight越大，负载的权重就越大。&lt;br&gt;3.max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误&lt;br&gt;4.fail_timeout:max_fails次失败后，暂停的时间。&lt;br&gt;5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。&lt;br&gt;nginx支持同时设置多组的负载均衡，用来给不用的server来使用。&lt;br&gt;client_body_in_file_only 设置为On 可以讲client post过来的数据记录到文件中用来做debug&lt;br&gt;client_body_temp_path 设置记录文件的目录 可以设置最多3层目录&lt;br&gt;location 对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;示例&lt;br&gt;3.1 网络拓扑&lt;br&gt;反向代理服务器 server1.example.com&lt;br&gt;后端服务器：&lt;br&gt;server2.example.com&lt;br&gt;server3.example.com&lt;br&gt;3.2 配置&lt;br&gt;3.2.1 server1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
user nginx;
worker_processes 1;
events {
 use epoll;
 worker_connections  1024;
}
http {
 include       mime.types;
 default_type  application/octet-stream;
 sendfile        on;
 keepalive_timeout  65;
 upstream nginx.com{
        server server2.example.com:80;
        server server3.example.com:80;
 }  
 server {
     listen       80;
     server_name  localhost;
     location / {
         proxy_pass http://nginx.com;
     proxy_set_header  X-Real-IP  $remote_addr;
   }
 error_page   500 502 503 504  /50x.html;
 location = /50x.html {
         root   html;
 }  
}  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装nginx&quot;&gt;&lt;a href=&quot;#安装nginx&quot; class=&quot;headerlink&quot; title=&quot;安装nginx&quot;&gt;&lt;/a&gt;安装nginx&lt;/h3&gt;&lt;p&gt;请参考&lt;a href=&quot;http://www.yaolinux.cn/blog/lnmp%25E6%
    
    </summary>
    
    
      <category term="lnmp,nginx" scheme="https://iceziyao.github.io/tags/lnmp-nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx配置文件详解</title>
    <link href="https://iceziyao.github.io/2015/12/23/nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>https://iceziyao.github.io/2015/12/23/nginx配置文件详解/</id>
    <published>2015-12-23T13:49:33.000Z</published>
    <updated>2016-07-09T15:48:20.029Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;


    #运行用户
    user nginx;   
    #启动进程,通常设置成和cpu的数量相等
    worker_processes  1;

    #全局错误日志及PID文件
    error_log  /var/log/nginx/error.log;
    pid        /var/run/nginx.pid;

    #工作模式及连接数上限
    events {
        use   epoll;             #epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能
        worker_connections  1024;#单个后台worker process进程的最大并发链接数
        # multi_accept on;
    }

    #设定http服务器，利用它的反向代理功能提供负载均衡支持
    http {
         #设定mime类型,类型由mime.type文件定义
        include       /etc/nginx/mime.types;
        default_type  application/octet-stream;
        #设定日志格式
        access_log    /var/log/nginx/access.log;

        #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，
        #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.
        sendfile        on;
        #tcp_nopush     on;

        #连接超时时间
        #keepalive_timeout  0;
        keepalive_timeout  65;
        tcp_nodelay        on;

        #开启gzip压缩
        gzip  on;
        gzip_disable &quot;MSIE [1-6]\.(?!.*SV1)&quot;;

        #设定请求缓冲
        client_header_buffer_size    1k;
        large_client_header_buffers  4 4k;

        include /etc/nginx/conf.d/*.conf;
        include /etc/nginx/sites-enabled/*;

        #设定负载均衡的服务器列表
         upstream mysvr {
        #weigth参数表示权值，权值越高被分配到的几率越大
        #本机上的Squid开启3128端口
        server 192.168.8.1:3128 weight=5;
        server 192.168.8.2:80  weight=1;
        server 192.168.8.3:80  weight=6;
        }


       server {
        #侦听80端口
            listen       80;
            #定义使用www.xx.com访问
            server_name  www.xx.com;

            #设定本虚拟主机的访问日志
            access_log  logs/www.xx.com.access.log  main;

        #默认请求
        location / {
              root   /root;      #定义服务器的默认网站根目录位置
              index index.php index.html index.htm;   #定义首页索引文件的名称

              fastcgi_pass  www.xx.com;
             fastcgi_param  SCRIPT_FILENAME  $document_root/$fastcgi_script_name;
              include /etc/nginx/fastcgi_params;
            }

        # 定义错误提示页面
        error_page   500 502 503 504 /50x.html;
            location = /50x.html {
            root   /root;
        }

        #静态文件，nginx自己处理
        location ~ ^/(images|javascript|js|css|flash|media|static)/ {
            root /var/www/virtual/htdocs;
            #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。
            expires 30d;
        }
        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.
        location ~ \.php$ {
            root /root;
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
            fastcgi_param SCRIPT_FILENAME /home/www/www$fastcgi_script_name;
            include fastcgi_params;
        }
        #设定查看Nginx状态的地址
        location /NginxStatus {
            stub_status              on;
            access_log               on;
            auth_basic              &quot;NginxStatus&quot;;
            auth_basic_user_file  conf/htpasswd;
        }
        #禁止访问 .htxxx 文件
        location ~ /\.ht {
            deny all;
        }

         }
    }

以上是一些基本的配置,使用Nginx最大的好处就是负载均衡

如果要使用负载均衡的话,可以修改配置http节点如下：

    #设定http服务器，利用它的反向代理功能提供负载均衡支持
    http {
         #设定mime类型,类型由mime.type文件定义
        include       /etc/nginx/mime.types;
        default_type  application/octet-stream;
        #设定日志格式
        access_log    /var/log/nginx/access.log;

        #省略上文有的一些配置节点

        #。。。。。。。。。。

        #设定负载均衡的服务器列表
        upstream mysvr {
        #weigth参数表示权值，权值越高被分配到的几率越大
        server 192.168.8.1x:3128 weight=5;#本机上的Squid开启3128端口
        server 192.168.8.2x:80  weight=1;
        server 192.168.8.3x:80  weight=6;
        }

        upstream mysvr2 {
        #weigth参数表示权值，权值越高被分配到的几率越大

            server 192.168.8.x:80  weight=1;
            server 192.168.8.x:80  weight=6;
        }

       #第一个虚拟服务器
       server {
        #侦听192.168.8.x的80端口
            listen       80;
            server_name  192.168.8.x;

            #对aspx后缀的进行负载均衡请求
            location ~ .*\.aspx$ {

                root   /root;      #定义服务器的默认网站根目录位置
                index index.php index.html index.htm;   #定义首页索引文件的名称

                proxy_pass  http://mysvr ;#请求转向mysvr 定义的服务器列表

                #以下是一些反向代理的配置可删除.

                proxy_redirect off;

                #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                client_max_body_size 10m;       #允许客户端请求的最大单文件字节数
                client_body_buffer_size 128k;   #缓冲区代理缓冲用户端请求的最大字节数，
                proxy_connect_timeout 90;       #nginx跟后端服务器连接超时时间(代理连接超时)
                proxy_send_timeout 90;          #后端服务器数据回传时间(代理发送超时)
                proxy_read_timeout 90;          #连接成功后，后端服务器响应时间(代理接收超时)
                proxy_buffer_size 4k;           #设置代理服务器（nginx）保存用户头信息的缓冲区大小
                proxy_buffers 4 32k;            #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置
                proxy_busy_buffers_size 64k;    #高负荷下缓冲大小（proxy_buffers*2）
                proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传

           }

         }
    }

&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;pre&gt;&lt;code&gt;


    #运行用户
    user nginx;   
    #启动进程,通常设置成和cpu的数量相等
    worker_processes  1;

    #全局错误日志及PID文件
    error_log  /var/log
    
    </summary>
    
    
      <category term="lnmp,nginx" scheme="https://iceziyao.github.io/tags/lnmp-nginx/"/>
    
  </entry>
  
  <entry>
    <title>ftp+mysql搭建ftp认证</title>
    <link href="https://iceziyao.github.io/2015/11/24/ftp+mysql/"/>
    <id>https://iceziyao.github.io/2015/11/24/ftp+mysql/</id>
    <published>2015-11-24T03:49:33.000Z</published>
    <updated>2016-07-09T17:08:28.877Z</updated>
    
    <content type="html">&lt;p&gt;一、安装所需要程序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事先安装好开发环境和mysql数据库;&lt;br&gt;&lt;code&gt;# yum -y install mysql-server mysql-devel&lt;/code&gt;&lt;br&gt;&lt;code&gt;# yum -y groupinstall &amp;quot;Development Tools&amp;quot; &amp;quot;Development Libraries&amp;quot;&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;安装pam_mysql-0.7RC1  &lt;pre&gt;&lt;code&gt;# tar zxvf  pam_mysql-0.7RC1.tar.gz
# cd  pam_mysql-0.7RC1
# ./configure --with-mysql=/usr --with-openssl
# make
# make install  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;安装vsftpd&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;yum -y install vsftpd&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二、创建虚拟用户账号  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;准备数据库及相关表&lt;br&gt;首先请确保mysql服务已经正常启动。而后，按需要建立存储虚拟用户的数据库即可，这里将其创建为vsftpd数据库。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;create database vsftpd;&lt;br&gt;grant select on vsftpd.&lt;em&gt; to vsftpd@localhost identified by ‘www.magedu.com’;&lt;br&gt;mysql&amp;gt; grant select on vsftpd.&lt;/em&gt; to vsftpd@127.0.0.1 identified by ‘www.magedu.com’;&lt;br&gt;mysql&amp;gt; flush privileges;&lt;br&gt;mysql&amp;gt; use vsftpd;&lt;br&gt;mysql&amp;gt; create table users (&lt;br&gt; -&amp;gt; id int AUTO_INCREMENT NOT NULL,&lt;br&gt; -&amp;gt; name char(20) binary NOT NULL,&lt;br&gt; -&amp;gt; password char(48) binary NOT NULL,&lt;br&gt; -&amp;gt; primary key(id)&lt;br&gt; -&amp;gt; );  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加测试的虚拟用户&lt;br&gt;根据需要添加所需要的用户，需要说明的是，这里将其密码采用明文格式存储，原因是pam_mysql的password()函数与MySQL的password()函数可能会有所不同.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; insert into users(name,password) values(&amp;apos;tom&amp;apos;,&amp;apos;magedu&amp;apos;);
mysql&amp;gt; insert into users(name,password) values(&amp;apos;jerry&amp;apos;,&amp;apos;magedu&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三、配置vsftpd&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;建立pam认证所需文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#vi /etc/pam.d/vsftpd.mysql
添加如下两行
auth required /lib/security/pam_mysql.so   user=vsftpd passwd=www.magedu.com
host=localhost
db=vsftpd
table=users
usercolumn=name
passwdcolumn=password
crypt=0
account required /lib/security/pam_mysql.so user=vsftpd
passwd=www.magedu.com
host=localhost
db=vsftpd
table=users
usercolumn=name
passwdcolumn=password
crypt=0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改vsftpd的配置文件，使其适应mysql认证&lt;br&gt;建立虚拟用户映射的系统用户及对应的目录  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#useradd -s /sbin/nologin -d /var/ftproot vuser
#chmod go+rx /var/ftproot
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请确保/etc/vsftpd.conf中已经启用了以下选项  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;anonymous_enable=YES&lt;br&gt;local_enable=YES&lt;br&gt;write_enable=YES&lt;br&gt;anon_upload_enable=NO&lt;br&gt;anon_mkdir_write_enable=NO&lt;br&gt;chroot_local_user=YES&lt;br&gt;而后添加以下选项&lt;br&gt;guest_enable=YES&lt;br&gt;guest_username=vuser&lt;br&gt;并确保pam_service_name选项的值如下所示&lt;br&gt;pam_service_name=vsftpd.mysql  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;四、启动vsftpd服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# service vsftpd start
# chkconfig vsftpd on
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看端口开启情况  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# netstat -tnlp |grep :21
tcp         0      0 0.0.0.0:21              0.0.0.0:*               LISTEN      23286/vsftpd
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用虚拟用户登录,验正配置结果，以下为本机的命令方式测试，你也可以在其它Win Box上用IE或者FTP客户端工具登录验正  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ftp localhost
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;五、配置虚拟用户具有不同的访问权限&lt;br&gt;vsftpd可以在配置文件目录中为每个用户提供单独的配置文件以定义其ftp服务访问权限，每个虚拟用户的配置文件名同虚拟用户的用户名。配置文件目录可以是任意未使用目录，只需要在vsftpd.conf指定其路径及名称即可。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;配置vsftpd为虚拟用户使用配置文件目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# vim vsftpd.conf
添加如下选项
user_config_dir=/etc/vsftpd/vusers_dir
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建所需要目录，并为虚拟用户提供配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mkdir /etc/vsftpd/vusers_dir/
# cd /etc/vsftpd/vusers_dir/
# touch tom jerry
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;配置虚拟用户的访问权限&lt;br&gt;虚拟用户对vsftpd服务的访问权限是通过匿名用户的相关指令进行的。比如，如果需要让tom用户具有上传文件的权限，可以修改/etc/vsftpd/vusers/tom文件，在里面添加如下选项即可。&lt;br&gt;&lt;code&gt;anon_upload_enable=YES&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一、安装所需要程序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事先安装好开发环境和mysql数据库;&lt;br&gt;&lt;code&gt;# yum -y install mysql-server mysql-devel&lt;/code&gt;&lt;br&gt;&lt;code&gt;# yum -y groupinstall &amp;quot
    
    </summary>
    
    
      <category term="ftp" scheme="https://iceziyao.github.io/tags/ftp/"/>
    
  </entry>
  
  <entry>
    <title>ajax初探</title>
    <link href="https://iceziyao.github.io/2015/01/02/ajax/"/>
    <id>https://iceziyao.github.io/2015/01/02/ajax/</id>
    <published>2015-01-01T16:00:00.000Z</published>
    <updated>2016-07-09T20:57:32.073Z</updated>
    
    <content type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ajax简介  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。  &lt;/li&gt;
&lt;li&gt;AJAX = 异步 JavaScript和XML（标准通用标记语言的子集）。  &lt;/li&gt;
&lt;li&gt;AJAX 是一种用于创建快速动态网页的技术。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发展  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在web1.0中，我们需要对页面上的数据进行更新时，需要对整个页面进行重载。这样，每次更改局部信息时，都要进行所有后台数据的全部读取。在网速缓慢的情况下，这会让用户等待时间较长。&lt;/li&gt;
&lt;li&gt;在web2.0下，我们可以设想这样一种方式，局部的更改数据，而不是加载整个页面。&lt;br&gt;2.1 如何更改页面信息呢？&lt;br&gt;可以使用js，它可以将页面上的元素进行更改。学过前端的都知道，js是可以获取到页面元素，并且修改元素的。&lt;br&gt;2.2 如何与后台进行交互？&lt;br&gt;那么，我们必须向后台进行请求，可以用个超链接&lt;code&gt;&amp;lt;a href=&amp;#39;#&amp;#39; title=&amp;#39;&amp;#39; target=_blank&amp;lt;/a&amp;gt;&lt;/code&gt;,向后台请求。那么问题来了，页面上的很多东西都会改变，都用超链接？这不现实。&lt;br&gt;可不可以让js和后台通过一种机制，直接交互呢？所以ajax产生了。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工作原理&lt;br&gt;Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。&lt;br&gt;XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所以我们先从XMLHttpRequest讲起，来看看它的工作原理。&lt;br&gt;　  首先，我们先来看看XMLHttpRequest这个对象的属性。&lt;br&gt;　　它的属性有:  &lt;ul&gt;
&lt;li&gt;onreadystatechange  每次状态改变所触发事件的事件处理程序。&lt;/li&gt;
&lt;li&gt;responseText     从服务器进程返回数据的字符串形式。&lt;/li&gt;
&lt;li&gt;responseXML    从服务器进程返回的DOM兼容的文档数据对象。&lt;/li&gt;
&lt;li&gt;status           从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）&lt;/li&gt;
&lt;li&gt;status Text       伴随状态码的字符串信息&lt;/li&gt;
&lt;li&gt;readyState       对象状态值  &lt;blockquote&gt;
&lt;p&gt;0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）&lt;br&gt;　　 1 (初始化) 对象已建立，尚未调用send方法&lt;br&gt;　　 2 (发送数据) send方法已调用，但是当前的状态及http头未知&lt;br&gt;　　 3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，&lt;br&gt;　　4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ajax的使用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建XMLHTTPReq&lt;/li&gt;
&lt;li&gt;发送数据&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接受回调数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var XMLHttpReq=null;
//创建Ajax引擎对象
function createXMLHttpRequest() {
 try {
        XMLHttpReq = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);//IE高版本创建XMLHTTP
     }
     catch(E) {
        try {
               XMLHttpReq = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE低版本创建XMLHTTP
        }
        catch(E) {
               XMLHttpReq = new XMLHttpRequest();//兼容非IE浏览器，直接创建XMLHTTP对象
        }
      }
}
//向后台发送数据
function sendGetAjaxRequest(url,text) {
      createXMLHttpRequest();                                //创建XMLHttpRequest对象
      XMLHttpReq.open(&quot;get&quot;, url+&quot;?&quot;+encodeURI(text), true);
     XMLHttpReq.onreadystatechange = doResult; //指定响应函数
     XMLHttpReq.send(null);
}
function sendPOSTAjaxRequest(url,text) {
      createXMLHttpRequest();                                //创建XMLHttpRequest对象
      XMLHttpReq.open(&quot;post&quot;, url, true);
      XMLHttpReq.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);
      XMLHttpReq.setRequestHeader(&quot;Content-length&quot;, text.length);
      XMLHttpReq.setRequestHeader(&quot;Connection&quot;, &quot;close&quot;);
      XMLHttpReq.onreadystatechange = doResult; //指定响应函数
      XMLHttpReq.send(null);
}
function doResult() {
   if (XMLHttpReq.readyState == 4 &amp;&amp; XMLHttpReq.status == 200) {
     //4代表执行完成                
     //200代表执行成功，删除当前表格

   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;ajax的优缺点&lt;ul&gt;
&lt;li&gt;优点：&lt;ul&gt;
&lt;li&gt;就是能在不更新整个页面的前提下维护数据。这使得Web应用程序更为迅捷地回应用户动作，并避免了在网络上发送那些没有改变过的信息。&lt;/li&gt;
&lt;li&gt;异步非阻塞&lt;/li&gt;
&lt;li&gt;可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。&lt;/li&gt;
&lt;li&gt;基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：&lt;ul&gt;
&lt;li&gt;用户不知道数据是否更新&lt;/li&gt;
&lt;li&gt;无法回退&lt;/li&gt;
&lt;li&gt;安全问题&lt;br&gt;任何数据处理在前端，都会暴露后台&lt;/li&gt;
&lt;li&gt;对串流媒体的支持没有FLASH、Java Applet好;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;ajax简介  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。  &lt;/li&gt;
&lt;li&gt;AJAX = 异步 JavaSc
    
    </summary>
    
    
      <category term="ajax" scheme="https://iceziyao.github.io/tags/ajax/"/>
    
  </entry>
  
</feed>
