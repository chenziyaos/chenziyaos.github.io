<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>非衣</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://iceziyao.github.io/"/>
  <updated>2016-07-09T15:46:50.804Z</updated>
  <id>https://iceziyao.github.io/</id>
  
  <author>
    <name>陈子瑶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Memcached简介</title>
    <link href="https://iceziyao.github.io/2016/01/01/Memcached/"/>
    <id>https://iceziyao.github.io/2016/01/01/Memcached/</id>
    <published>2016-01-01T13:49:33.000Z</published>
    <updated>2016-07-09T15:46:50.804Z</updated>
    
    <content type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Memcached是一款开源、高性能、分布式内存对象缓存系统，可应用各种需要缓存的场景，其主要目的是通过降低对Database的访问来加速web应用程序。它是一个基于内存的“键值对”存储，用于存储数据库调用、API调用或页面引用结果的直接数据，如字符串、对象等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;memcached是以LiveJournal旗下Danga Interactive 公司的Brad Fitzpatric 为首开发的一款软件。现在&lt;br&gt;已成为mixi、hatena、Facebook、Vox、LiveJournal等众多服务中提高Web应用扩展性的重要因素。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Memcached是一款开发工具，它既不是一个代码加速器，也不是数据库中间件。其设计哲学思想主要反映在如下方面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;简单key/value存储：服务器不关心数据本身的意义及结构，只要是可序列化数据即可。存储项由“键、过期时间、可选的标志及数据”四个部分组成；  &lt;/li&gt;
&lt;li&gt;功能的实现一半依赖于客户端，一半基于服务器端：客户负责发送存储项至服务器端、从服务端获取数据以及无法连接至服务器时采用相应的动作；服务端负责接收、存储数据，并负责数据项的超时过期；  &lt;/li&gt;
&lt;li&gt;各服务器间彼此无视：不在服务器间进行数据同步；  &lt;/li&gt;
&lt;li&gt;O(1)的执行效率  &lt;/li&gt;
&lt;li&gt;清理超期数据：默认情况下，Memcached是一个LRU缓存，同时，它按事先预订的时长清理超期数据；&lt;br&gt;但事实上，memcached不会删除任何已缓存数据，只是在其过期之后不再为客户所见；&lt;br&gt;而且，memcached也不会真正按期限清理缓存，而仅是当get命令到达时检查其时长；   &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Memcached提供了为数不多的几个命令来完成与服务器端的交互，这些命令基于memcached的协议实现。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;存储类命令：set, add, replace, append, prepend&lt;br&gt;获取数据类命令：get, delete, incr/decr&lt;br&gt;统计类命令：stats, stats items, stats slabs, stats sizes&lt;br&gt;清理命令： flush_all  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一、安装libevent&lt;br&gt;memcached依赖于libevent API，因此要事先安装之，项目主页：&lt;a href=&quot;http://libevent.org/，读者可自行选择需要的版本下载。本文采用的是目前最新版本的源码包libevent-2.0.16-stable.tar.gz。安装过程：&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://libevent.org/，读者可自行选择需要的版本下载。本文采用的是目前最新版本的源码包libevent-2.0.16-stable.tar.gz。安装过程：&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
# tar xf libevent-2.0.20-stable.tar.gz
# cd libevent-2.0.20
# ./configure --prefix=/usr/local/libevent
# make &amp;&amp; make install

# echo &quot;/usr/local/libevent/lib&quot; &gt; /etc/ld.so.conf.d/libevent.conf
# ldconfig
&lt;/code&gt;&lt;/pre&gt;
二、安装配置memcached

1. 安装memcached
&lt;pre&gt;&lt;code&gt;
# tar xf memcached-1.4.15.tar.gz
# cd memcached-1.4.15
# ./configure --prefix=/usr/local/memcached --with-libevent=/usr/local/libevent
# make &amp;&amp; make install
&lt;/code&gt;&lt;/pre&gt;
2. memcached SysV的startup脚本代码如下所示，将其建立为/etc/init.d/memcached文件：
&lt;pre&gt;&lt;code&gt;
#!/bin/bash
#
# Init file for memcached
#
# chkconfig: - 86 14
# description: Distributed memory caching daemon
#
# processname: memcached
# config: /etc/sysconfig/memcached
. /etc/rc.d/init.d/functions
## Default variables
PORT=&quot;11211&quot;
USER=&quot;nobody&quot;
MAXCONN=&quot;1024&quot;
CACHESIZE=&quot;64&quot;
OPTIONS=&quot;&quot;
RETVAL=0
prog=&quot;/usr/local/memcached/bin/memcached&quot;
desc=&quot;Distributed memory caching&quot;
lockfile=&quot;/var/lock/subsys/memcached&quot;
start() {
        echo -n $&quot;Starting $desc (memcached): &quot;
        daemon $prog -d -p $PORT -u $USER -c $MAXCONN -m $CACHESIZE -o &quot;$OPTIONS&quot;
        RETVAL=$?
        echo
        [ $RETVAL -eq 0 ] &amp;&amp; touch $lockfile
        return $RETVAL
}
stop() {
        echo -n $&quot;Shutting down $desc (memcached): &quot;
        killproc $prog
        RETVAL=$?
        echo
        [ $RETVAL -eq 0 ] &amp;&amp; rm -f $lockfile
        return $RETVAL
}
restart() {
        stop
        start
}
reload() {
        echo -n $&quot;Reloading $desc ($prog): &quot;
        killproc $prog -HUP
        RETVAL=$?
        echo
        return $RETVAL
}
case &quot;$1&quot; in
  start)
        start
        ;;
  stop)
        stop
        ;;
  restart)
        restart
        ;;
  condrestart)
        [ -e $lockfile ] &amp;&amp; restart
        RETVAL=$?
        ;;       
  reload)
        reload
        ;;
  status)
        status $prog
        RETVAL=$?
        ;;
   \*)
        echo $&quot;Usage: $0 {start|stop|restart|condrestart|status}&quot;
        RETVAL=1
esac
exit $RETVAL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用如下命令配置memcached成为系统服务：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
# chmod +x /etc/init.d/memcached
# chkconfig --add memcached
# service memcached start
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;使用telnet命令测试memcached的使用&lt;br&gt;Memcached提供一组基本命令用于基于命令行调用其服务或查看服务器状态等。&lt;br&gt;&lt;code&gt;telnet 127.0.0.1 11211&lt;/code&gt;  &lt;blockquote&gt;
&lt;p&gt;add命令：&lt;br&gt;add keyname flag  timeout  datasize&lt;br&gt;如：&lt;br&gt;add mykey 0 10 12&lt;br&gt;Hello world!&lt;br&gt;get命令：&lt;br&gt;get keyname&lt;br&gt;如：get mykey&lt;br&gt;VALUE mykey 0 12&lt;br&gt;Hello world!&lt;br&gt;END  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;4.memcached的常用选项说明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
-l &lt;ip_addr&gt;：指定进程监听的地址；
-d: 以服务模式运行；
-u &lt;username&gt;：以指定的用户身份运行memcached进程；
-m &lt;num&gt;：用于缓存数据的最大内存空间，单位为MB，默认为64MB；
-c &lt;num&gt;：最大支持的并发连接数，默认为1024；
-p &lt;num&gt;: 指定监听的TCP端口，默认为11211；
-U &lt;num&gt;：指定监听的UDP端口，默认为11211，0表示关闭UDP端口；
-t &lt;threads&gt;：用于处理入站请求的最大线程数，仅在memcached编译时开启了支持线程才有效；
-f &lt;num&gt;：设定Slab Allocator定义预先分配内存空间大小固定的块时使用的增长因子；
-M：当内存空间不够使用时返回错误信息，而不是按LRU算法利用空间；
-n: 指定最小的slab chunk大小；单位是字节；
-S: 启用sasl进行用户认证；
&lt;/num&gt;&lt;/threads&gt;&lt;/num&gt;&lt;/num&gt;&lt;/num&gt;&lt;/num&gt;&lt;/username&gt;&lt;/ip_addr&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三、安装Memcache的PHP扩展&lt;/p&gt;
&lt;p&gt;①安装PHP的memcache扩展&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
# tar xf memcache-2.2.5.tgz
# cd memcache-2.2.5
/usr/local/php/bin/phpize
# ./configure --with-php-config=/usr/local/php/bin/php-config --enable-memcache
# make &amp;&amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述安装完后会有类似以下的提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Installing shared extensions:     /usr/local/php/lib/php/extensions/no-debug-non-zts-20090626/  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;②编辑/usr/local/php/lib/php.ini，在“动态模块”相关的位置添加如下一行来载入memcache扩展：&lt;br&gt;extension=/usr/local/php/lib/php/extensions/no-debug-non-zts-20090626/memcache.so&lt;br&gt;而后对memcached功能进行测试，在网站目录中建立测试页面test.php，添加如下内容：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;?php
$mem = new Memcache;
$mem-&gt;connect(&quot;127.0.0.1&quot;, 11211)  or die(&quot;Could not connect&quot;);
$version = $mem-&gt;getVersion();
echo &quot;Server&#39;s version: &quot;.$version.&quot;&lt;br&gt;\n&quot;;
$mem-&gt;set(&#39;testkey&#39;, &#39;Hello World&#39;, 0, 600) or die(&quot;Failed to save data at the memcached server&quot;);
echo &quot;Store data in the cache (data will expire in 600 seconds)&lt;br&gt;\n&quot;;
$get_result = $mem-&gt;get(&#39;testkey&#39;);
echo &quot;$get_result is from memcached server.&quot;;         
?&gt;
&lt;/code&gt;&lt;/pre&gt;  

&lt;p&gt;如果有输出”Hello World is from memcached”&lt;br&gt;等信息，则表明memcache已经能够正常工作&lt;/p&gt;
&lt;p&gt;四. 使用libmemcached的客户端工具:&lt;/p&gt;
&lt;p&gt;访问memcached的传统方法是使用基于perl语言开发的Cache::memcached模块，这个模块在大多数perl代码中都能良好的工作，但也有着众所周知的性能方面的问题。libMemcached则是基于C语言开发的开源的C/C++代码访问memcached的库文件，同时，它还提供了数个可以远程使用的memcached管理工具，如memcat, memping，memstat，memslap等。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编译安装libmemcached&lt;pre&gt;&lt;code&gt;
# tar xf libmemcached-1.0.2.tar.gz
# cd libmemcached-1.0.2
# ./configure
# make &amp;&amp; make install
# ldconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;客户端工具&lt;pre&gt;&lt;code&gt;
# memcat --servers=127.0.0.1:11211 mykey
# memping
# memslap
# memstat
&lt;/code&gt;&lt;/pre&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;五. Nginx整合memcached:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
server {
        listen       80;
        server_name  www.magedu.com;
        #charset koi8-r;
        #access_log  logs/host.access.log  main;
        location / {
                set $memcached_key $uri;
                memcached_pass     127.0.0.1:11211;
                default_type       text/html;
                error_page         404 @fallback;
        }
        location @fallback {
                proxy_pass http://172.16.0.1;
        }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;Memcached是一款开源、高性能、分布式内存对象缓存系统，可应用各种需要缓存的场景，其主要目的是通过降低对Database的访问来加速web应用程序。它是一个基于内存的“键值对”存储，用于存储数据库调用、API调用或页面引用结果的直接数据，如字符串、对
    
    </summary>
    
    
      <category term="缓存" scheme="https://iceziyao.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>nginx负载均衡</title>
    <link href="https://iceziyao.github.io/2015/12/23/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://iceziyao.github.io/2015/12/23/nginx负载均衡/</id>
    <published>2015-12-23T13:49:33.000Z</published>
    <updated>2016-07-09T15:47:21.221Z</updated>
    
    <content type="html">&lt;h3 id=&quot;安装nginx&quot;&gt;&lt;a href=&quot;#安装nginx&quot; class=&quot;headerlink&quot; title=&quot;安装nginx&quot;&gt;&lt;/a&gt;安装nginx&lt;/h3&gt;&lt;p&gt;请参考&lt;a href=&quot;http://www.yaolinux.cn/blog/lnmp%25E6%259E%25B6%25E6%259E%2584.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;lnmp架构&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;nginx 反向代理&lt;br&gt;nginx的负载均衡基于反向代理  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.1 正向代理  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 正向代理 是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.2反向代理&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;反向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;区别:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。&lt;br&gt;正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;upstream&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2.1 负载均衡算法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2.1.1 轮循&lt;br&gt;当weight不指定时，各服务器weight相同，&lt;br&gt;每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
upstream bakend {
server server1.example.com;
server server2.example.com;
}
&lt;/code&gt;&lt;/pre&gt;
2.1.2 weight    
指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。
如果后端服务器down掉，能自动剔除。
比如以下配置，则1.11服务器的访问量为1.10服务器的两倍。  
&lt;pre&gt;&lt;code&gt;
upstream bakend {
server server1.example.com weight=1;
server server2.example.com weight=2;
}
&lt;/code&gt;&lt;/pre&gt;
2.1.3 ip_hash        
每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session不能跨服务器的问题。  
&lt;pre&gt;&lt;code&gt;
upstream bakend {
ip_hash
server server1.example.com;
server server2.example.com;
}
&lt;/code&gt;&lt;/pre&gt;
2.1.4 fair  
按后端服务器的响应时间来分配请求，响应时间短的优先分配。  
&lt;pre&gt;&lt;code&gt;
upstream bakend {
server server1.example.com;
server server2.example.com;
fair;
}
&lt;/code&gt;&lt;/pre&gt;
2.1.5 url_hash  
按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存服务器时比较有效。
在upstream中加入hash语句，hash_method是使用的hash算法。  
&lt;pre&gt;&lt;code&gt;
upstream bakend {
server server1.example.com;
server server2.example.com;
hash $request_uri;
hash_method crc32;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;/blockquote&gt;
&lt;p&gt;2.2 参数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.down 表示单前的server暂时不参与负载&lt;br&gt;2.weight 默认为1.weight越大，负载的权重就越大。&lt;br&gt;3.max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误&lt;br&gt;4.fail_timeout:max_fails次失败后，暂停的时间。&lt;br&gt;5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。&lt;br&gt;nginx支持同时设置多组的负载均衡，用来给不用的server来使用。&lt;br&gt;client_body_in_file_only 设置为On 可以讲client post过来的数据记录到文件中用来做debug&lt;br&gt;client_body_temp_path 设置记录文件的目录 可以设置最多3层目录&lt;br&gt;location 对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;示例&lt;br&gt;3.1 网络拓扑&lt;br&gt;反向代理服务器 server1.example.com&lt;br&gt;后端服务器：&lt;br&gt;server2.example.com&lt;br&gt;server3.example.com&lt;br&gt;3.2 配置&lt;br&gt;3.2.1 server1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
user nginx;
worker_processes 1;
events {
 use epoll;
 worker_connections  1024;
}
http {
 include       mime.types;
 default_type  application/octet-stream;
 sendfile        on;
 keepalive_timeout  65;
 upstream nginx.com{
        server server2.example.com:80;
        server server3.example.com:80;
 }  
 server {
     listen       80;
     server_name  localhost;
     location / {
         proxy_pass http://nginx.com;
     proxy_set_header  X-Real-IP  $remote_addr;
   }
 error_page   500 502 503 504  /50x.html;
 location = /50x.html {
         root   html;
 }  
}  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装nginx&quot;&gt;&lt;a href=&quot;#安装nginx&quot; class=&quot;headerlink&quot; title=&quot;安装nginx&quot;&gt;&lt;/a&gt;安装nginx&lt;/h3&gt;&lt;p&gt;请参考&lt;a href=&quot;http://www.yaolinux.cn/blog/lnmp%25E6%
    
    </summary>
    
    
      <category term="lnmp,nginx" scheme="https://iceziyao.github.io/tags/lnmp-nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx配置文件详解</title>
    <link href="https://iceziyao.github.io/2015/12/23/nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>https://iceziyao.github.io/2015/12/23/nginx配置文件详解/</id>
    <published>2015-12-23T13:49:33.000Z</published>
    <updated>2016-07-09T15:48:20.029Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;


    #运行用户
    user nginx;   
    #启动进程,通常设置成和cpu的数量相等
    worker_processes  1;

    #全局错误日志及PID文件
    error_log  /var/log/nginx/error.log;
    pid        /var/run/nginx.pid;

    #工作模式及连接数上限
    events {
        use   epoll;             #epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能
        worker_connections  1024;#单个后台worker process进程的最大并发链接数
        # multi_accept on;
    }

    #设定http服务器，利用它的反向代理功能提供负载均衡支持
    http {
         #设定mime类型,类型由mime.type文件定义
        include       /etc/nginx/mime.types;
        default_type  application/octet-stream;
        #设定日志格式
        access_log    /var/log/nginx/access.log;

        #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，
        #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.
        sendfile        on;
        #tcp_nopush     on;

        #连接超时时间
        #keepalive_timeout  0;
        keepalive_timeout  65;
        tcp_nodelay        on;

        #开启gzip压缩
        gzip  on;
        gzip_disable &quot;MSIE [1-6]\.(?!.*SV1)&quot;;

        #设定请求缓冲
        client_header_buffer_size    1k;
        large_client_header_buffers  4 4k;

        include /etc/nginx/conf.d/*.conf;
        include /etc/nginx/sites-enabled/*;

        #设定负载均衡的服务器列表
         upstream mysvr {
        #weigth参数表示权值，权值越高被分配到的几率越大
        #本机上的Squid开启3128端口
        server 192.168.8.1:3128 weight=5;
        server 192.168.8.2:80  weight=1;
        server 192.168.8.3:80  weight=6;
        }


       server {
        #侦听80端口
            listen       80;
            #定义使用www.xx.com访问
            server_name  www.xx.com;

            #设定本虚拟主机的访问日志
            access_log  logs/www.xx.com.access.log  main;

        #默认请求
        location / {
              root   /root;      #定义服务器的默认网站根目录位置
              index index.php index.html index.htm;   #定义首页索引文件的名称

              fastcgi_pass  www.xx.com;
             fastcgi_param  SCRIPT_FILENAME  $document_root/$fastcgi_script_name;
              include /etc/nginx/fastcgi_params;
            }

        # 定义错误提示页面
        error_page   500 502 503 504 /50x.html;
            location = /50x.html {
            root   /root;
        }

        #静态文件，nginx自己处理
        location ~ ^/(images|javascript|js|css|flash|media|static)/ {
            root /var/www/virtual/htdocs;
            #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。
            expires 30d;
        }
        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.
        location ~ \.php$ {
            root /root;
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
            fastcgi_param SCRIPT_FILENAME /home/www/www$fastcgi_script_name;
            include fastcgi_params;
        }
        #设定查看Nginx状态的地址
        location /NginxStatus {
            stub_status              on;
            access_log               on;
            auth_basic              &quot;NginxStatus&quot;;
            auth_basic_user_file  conf/htpasswd;
        }
        #禁止访问 .htxxx 文件
        location ~ /\.ht {
            deny all;
        }

         }
    }

以上是一些基本的配置,使用Nginx最大的好处就是负载均衡

如果要使用负载均衡的话,可以修改配置http节点如下：

    #设定http服务器，利用它的反向代理功能提供负载均衡支持
    http {
         #设定mime类型,类型由mime.type文件定义
        include       /etc/nginx/mime.types;
        default_type  application/octet-stream;
        #设定日志格式
        access_log    /var/log/nginx/access.log;

        #省略上文有的一些配置节点

        #。。。。。。。。。。

        #设定负载均衡的服务器列表
        upstream mysvr {
        #weigth参数表示权值，权值越高被分配到的几率越大
        server 192.168.8.1x:3128 weight=5;#本机上的Squid开启3128端口
        server 192.168.8.2x:80  weight=1;
        server 192.168.8.3x:80  weight=6;
        }

        upstream mysvr2 {
        #weigth参数表示权值，权值越高被分配到的几率越大

            server 192.168.8.x:80  weight=1;
            server 192.168.8.x:80  weight=6;
        }

       #第一个虚拟服务器
       server {
        #侦听192.168.8.x的80端口
            listen       80;
            server_name  192.168.8.x;

            #对aspx后缀的进行负载均衡请求
            location ~ .*\.aspx$ {

                root   /root;      #定义服务器的默认网站根目录位置
                index index.php index.html index.htm;   #定义首页索引文件的名称

                proxy_pass  http://mysvr ;#请求转向mysvr 定义的服务器列表

                #以下是一些反向代理的配置可删除.

                proxy_redirect off;

                #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                client_max_body_size 10m;       #允许客户端请求的最大单文件字节数
                client_body_buffer_size 128k;   #缓冲区代理缓冲用户端请求的最大字节数，
                proxy_connect_timeout 90;       #nginx跟后端服务器连接超时时间(代理连接超时)
                proxy_send_timeout 90;          #后端服务器数据回传时间(代理发送超时)
                proxy_read_timeout 90;          #连接成功后，后端服务器响应时间(代理接收超时)
                proxy_buffer_size 4k;           #设置代理服务器（nginx）保存用户头信息的缓冲区大小
                proxy_buffers 4 32k;            #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置
                proxy_busy_buffers_size 64k;    #高负荷下缓冲大小（proxy_buffers*2）
                proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传

           }

         }
    }

&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;pre&gt;&lt;code&gt;


    #运行用户
    user nginx;   
    #启动进程,通常设置成和cpu的数量相等
    worker_processes  1;

    #全局错误日志及PID文件
    error_log  /var/log
    
    </summary>
    
    
      <category term="lnmp,nginx" scheme="https://iceziyao.github.io/tags/lnmp-nginx/"/>
    
  </entry>
  
  <entry>
    <title>ftp+mysql搭建ftp认证</title>
    <link href="https://iceziyao.github.io/2015/11/24/ftp+mysql/"/>
    <id>https://iceziyao.github.io/2015/11/24/ftp+mysql/</id>
    <published>2015-11-24T03:49:33.000Z</published>
    <updated>2016-07-09T17:08:28.877Z</updated>
    
    <content type="html">&lt;p&gt;一、安装所需要程序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事先安装好开发环境和mysql数据库;&lt;br&gt;&lt;code&gt;# yum -y install mysql-server mysql-devel&lt;/code&gt;&lt;br&gt;&lt;code&gt;# yum -y groupinstall &amp;quot;Development Tools&amp;quot; &amp;quot;Development Libraries&amp;quot;&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;安装pam_mysql-0.7RC1  &lt;pre&gt;&lt;code&gt;# tar zxvf  pam_mysql-0.7RC1.tar.gz
# cd  pam_mysql-0.7RC1
# ./configure --with-mysql=/usr --with-openssl
# make
# make install  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;安装vsftpd&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;yum -y install vsftpd&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二、创建虚拟用户账号  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;准备数据库及相关表&lt;br&gt;首先请确保mysql服务已经正常启动。而后，按需要建立存储虚拟用户的数据库即可，这里将其创建为vsftpd数据库。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;create database vsftpd;&lt;br&gt;grant select on vsftpd.&lt;em&gt; to vsftpd@localhost identified by ‘www.magedu.com’;&lt;br&gt;mysql&amp;gt; grant select on vsftpd.&lt;/em&gt; to vsftpd@127.0.0.1 identified by ‘www.magedu.com’;&lt;br&gt;mysql&amp;gt; flush privileges;&lt;br&gt;mysql&amp;gt; use vsftpd;&lt;br&gt;mysql&amp;gt; create table users (&lt;br&gt; -&amp;gt; id int AUTO_INCREMENT NOT NULL,&lt;br&gt; -&amp;gt; name char(20) binary NOT NULL,&lt;br&gt; -&amp;gt; password char(48) binary NOT NULL,&lt;br&gt; -&amp;gt; primary key(id)&lt;br&gt; -&amp;gt; );  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加测试的虚拟用户&lt;br&gt;根据需要添加所需要的用户，需要说明的是，这里将其密码采用明文格式存储，原因是pam_mysql的password()函数与MySQL的password()函数可能会有所不同.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; insert into users(name,password) values(&amp;apos;tom&amp;apos;,&amp;apos;magedu&amp;apos;);
mysql&amp;gt; insert into users(name,password) values(&amp;apos;jerry&amp;apos;,&amp;apos;magedu&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三、配置vsftpd&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;建立pam认证所需文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#vi /etc/pam.d/vsftpd.mysql
添加如下两行
auth required /lib/security/pam_mysql.so   user=vsftpd passwd=www.magedu.com
host=localhost
db=vsftpd
table=users
usercolumn=name
passwdcolumn=password
crypt=0
account required /lib/security/pam_mysql.so user=vsftpd
passwd=www.magedu.com
host=localhost
db=vsftpd
table=users
usercolumn=name
passwdcolumn=password
crypt=0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改vsftpd的配置文件，使其适应mysql认证&lt;br&gt;建立虚拟用户映射的系统用户及对应的目录  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#useradd -s /sbin/nologin -d /var/ftproot vuser
#chmod go+rx /var/ftproot
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请确保/etc/vsftpd.conf中已经启用了以下选项  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;anonymous_enable=YES&lt;br&gt;local_enable=YES&lt;br&gt;write_enable=YES&lt;br&gt;anon_upload_enable=NO&lt;br&gt;anon_mkdir_write_enable=NO&lt;br&gt;chroot_local_user=YES&lt;br&gt;而后添加以下选项&lt;br&gt;guest_enable=YES&lt;br&gt;guest_username=vuser&lt;br&gt;并确保pam_service_name选项的值如下所示&lt;br&gt;pam_service_name=vsftpd.mysql  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;四、启动vsftpd服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# service vsftpd start
# chkconfig vsftpd on
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看端口开启情况  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# netstat -tnlp |grep :21
tcp         0      0 0.0.0.0:21              0.0.0.0:*               LISTEN      23286/vsftpd
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用虚拟用户登录,验正配置结果，以下为本机的命令方式测试，你也可以在其它Win Box上用IE或者FTP客户端工具登录验正  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ftp localhost
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;五、配置虚拟用户具有不同的访问权限&lt;br&gt;vsftpd可以在配置文件目录中为每个用户提供单独的配置文件以定义其ftp服务访问权限，每个虚拟用户的配置文件名同虚拟用户的用户名。配置文件目录可以是任意未使用目录，只需要在vsftpd.conf指定其路径及名称即可。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;配置vsftpd为虚拟用户使用配置文件目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# vim vsftpd.conf
添加如下选项
user_config_dir=/etc/vsftpd/vusers_dir
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建所需要目录，并为虚拟用户提供配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mkdir /etc/vsftpd/vusers_dir/
# cd /etc/vsftpd/vusers_dir/
# touch tom jerry
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;配置虚拟用户的访问权限&lt;br&gt;虚拟用户对vsftpd服务的访问权限是通过匿名用户的相关指令进行的。比如，如果需要让tom用户具有上传文件的权限，可以修改/etc/vsftpd/vusers/tom文件，在里面添加如下选项即可。&lt;br&gt;&lt;code&gt;anon_upload_enable=YES&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一、安装所需要程序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事先安装好开发环境和mysql数据库;&lt;br&gt;&lt;code&gt;# yum -y install mysql-server mysql-devel&lt;/code&gt;&lt;br&gt;&lt;code&gt;# yum -y groupinstall &amp;quot
    
    </summary>
    
    
      <category term="ftp" scheme="https://iceziyao.github.io/tags/ftp/"/>
    
  </entry>
  
</feed>
